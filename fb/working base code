from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
import datetime
import time
import pandas as pd
import undetected_chromedriver as uc
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
import random
import threading
import os
import csv
import variations
import pyautogui
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from urllib.parse import urlparse
import ssl
import openpyxl
from openpyxl.styles import Alignment, Font


ssl._create_default_https_context = ssl._create_unverified_context
pyautogui.FAILSAFE = False


# Function to log start and end time in the same row
def log_to_csv(filename, start_time, end_time):
    # Load the CSV file
    df = pd.read_csv(filename)

    # Ensure 'session number' column is treated as a number
    df['session number'] = pd.to_numeric(df['session number'], errors='coerce')

    # Find the next session number
    max_session = df['session number'].max()
    next_session = 1 if pd.isna(max_session) else int(max_session) + 1  # Convert to int

    print(f"Next session number to be entered: {next_session}")
    """Appends a row with start time and end time to the CSV file."""
    with open(filename, mode="a", newline="") as file:
        writer = csv.writer(file)
        writer.writerow([next_session, start_time, end_time])

# Define CSV file name
csv_filename = "execution_log.csv"


def human_like_typing(element, text):
    for char in text:
        element.send_keys(char)
        time.sleep(random.uniform(0.1, 0.3))  # Random delay between keystrokes

def can_send_message():
    print("I am in can send message")
    # Load the Excel file
    df = pd.read_excel(r"C:\Users\Mahnoor-Zubair\Desktop\main - Copy\main - Copy\visited_profiles.xlsx")

    # Filter rows where Status == "sent"
    filtered_df = df[df["Status"] == "sent"][["Last_Message_Time"]]

    if filtered_df.empty:
        return True  # If no previous messages, allow sending

    now = datetime.datetime.now()

    # Count how many messages were sent in the last hour   hours=0.06
    recent_messages = filtered_df[filtered_df["Last_Message_Time"] > now - datetime.timedelta(hours=1)]

    if len(recent_messages) < 2:  # Allow up to 2 messages per hour
        print(f"âœ… Allowed: {len(recent_messages)} messages sent in the last hour.")
        return True

    # If 2 messages have already been sent, calculate the wait time
    oldest_time = recent_messages["Last_Message_Time"].min()
    remaining_time = 3600 - (now - oldest_time).total_seconds()
    remaining_minutes = int(remaining_time // 60)
    remaining_seconds = int(remaining_time % 60)

    print(f"â³ Rate limit reached: Next message in {remaining_minutes} min {remaining_seconds} sec")
    return False


def move_cursor_to_element(element):
    location = element.location
    size = element.size

    # Calculate the center of the element
    x = location['x'] + size['width'] // 2
    y = location['y'] + size['height'] // 2 + 30

    # Move the cursor to the element and click
    pyautogui.moveTo(x, y, duration=0.5)

def open_website(driver):
    websites = [
                    'https://www.w3schools.com/', 
                    'https://egeeksglobal.com/', 
                    'https://newbreak.church/blog/?gad_source=1&gclid=EAIaIQobChMIntaAudXjiwMVxJiDBx1IagDfEAAYASAAEgJ-bPD_BwE',
                    'https://pubmed.ncbi.nlm.nih.gov/', 
                    'https://pubmed.ncbi.nlm.nih.gov/20890834/'
                ]

    # Choose a random website
    random_website = random.choice(websites)
    driver.get(random_website)
    time.sleep(random.randint(3, 10))  # Wait for the new tab to load
    all_windows = driver.window_handles
    main_window = driver.current_window_handle
    # # The new tab should be the last handle in the list (if you haven't opened multiple)
    # new_tab = [handle for handle in all_windows if handle != main_window][0]
    # driver.switch_to.window(new_tab)
    # Perform multiple random scrolls
    num_scrolls = random.randint(2, 5)  # Random number of scrolls
    for _ in range(num_scrolls):
        scroll_amount = random.randint(100, 500)  # Random scroll distance
        driver.execute_script(f"window.scrollBy(0, {scroll_amount});")
        time.sleep(random.uniform(1, 3))  # Random wait time between scrolls

    
    # Check for a search bar
    try:
        search_box = WebDriverWait(driver, 5).until(
            EC.presence_of_element_located((By.XPATH, "//input[@type='search']"))
        )
        search_terms = ["Python", "AI automation", "Selenium tutorial", "Web scraping"]
        search_box.send_keys(random.choice(search_terms))
        search_box.send_keys(Keys.RETURN)
        print("Search bar found and searched something.")
        time.sleep(random.randint(3, 7))

    except:
        print("No search bar found. Clicking a random link.")
        try:
            # Find all links on the page
            links = driver.find_elements(By.TAG_NAME, "a")
            if links:
                random.choice(links).click()
                print("Clicked a random link.")
                time.sleep(random.randint(3, 7))
        except:    
            print("No links found.")
            pass

    # Wait a bit before closing (to simulate user behavior)
    time.sleep(random.randint(3, 5))
    

def see_notifications(driver):
    driver.get("https://www.facebook.com/")
    # Find the Notifications button using its class or role attribute
    notifications_button = driver.find_element(By.XPATH, '//div[@role="button" and contains(@aria-label, "Notifications")]')
    move_cursor_to_element(notifications_button)
    # Click the button
    notifications_button.click()
    # Optional: Wait and close browser
    time.sleep(5)
def my_profile(driver):
    driver.get("https://www.facebook.com/")
    # Find the "Your profile" button using XPath
    profile_button = driver.find_element(By.XPATH, '//div[@role="button" and contains(@aria-label, "Your profile")]')
    move_cursor_to_element(profile_button)

    # Click the button
    profile_button.click()

    # Optional: Wait and then close the browser
    time.sleep(5)
def see_menu(driver):
    driver.get("https://www.facebook.com/")
    # Find the "Menu" button using XPath
    menu_button = driver.find_element(By.XPATH, '//div[@role="button" and contains(@aria-label, "Menu")]')
    move_cursor_to_element(menu_button)

    # Click the button
    menu_button.click()

    # Optional: Wait and then close the browser
    time.sleep(5)
def see_messenger(driver):
    driver.get("https://www.facebook.com/")
    # Find the "Messenger" button using XPath
    messenger_button = driver.find_element(By.XPATH, '//div[@role="button" and contains(@aria-label, "Messenger")]')
    move_cursor_to_element(messenger_button)

    # Click the button
    messenger_button.click()

    # Optional: Wait and then close the browser
    time.sleep(5)
def see_memories(driver):
    driver.get("https://www.facebook.com/")
    memories_button = WebDriverWait(driver, 10).until(
    EC.element_to_be_clickable((By.XPATH, "//span[text()='Memories']"))
    )
    move_cursor_to_element(memories_button)

    # Click the 'Memories' button
    memories_button.click()
    time.sleep(5)
def see_addsManager(driver):
    driver.get("https://www.facebook.com/")
    addsManager = WebDriverWait(driver, 10).until(
    EC.element_to_be_clickable((By.XPATH, "//span[text()='Ads Manager']"))
    )
    move_cursor_to_element(addsManager)
    # Click the 'Memories' button
    addsManager.click()
    time.sleep(5)

def see_event(driver):
    driver.get("https://www.facebook.com/")
    event_button = WebDriverWait(driver, 10).until(
    EC.element_to_be_clickable((By.XPATH, "//span[text()='Events']"))
    )
    move_cursor_to_element(event_button)

    # Click the 'Memories' button
    event_button.click()
    time.sleep(5)

def see_videos(driver):
    driver.get("https://www.facebook.com/")
    videos_button = WebDriverWait(driver, 10).until(
    EC.element_to_be_clickable((By.XPATH, "//span[text()='Video']"))
    )
    move_cursor_to_element(videos_button)

    # Click the 'Memories' button
    videos_button.click()
    time.sleep(5)

def my_variations(driver):
    main_window = driver.current_window_handle
    # Open a new tab
    # Open a new tab
    driver.execute_script("window.open('');")  # Open a blank new tab
    time.sleep(2)  # Wait for the new tab to load
    all_windows = driver.window_handles

    # The new tab should be the last handle in the list (if you haven't opened multiple)
    new_tab = [handle for handle in all_windows if handle != main_window][0]
    driver.switch_to.window(new_tab)
    actions = [open_website,see_menu,see_messenger,see_memories,see_videos, see_addsManager,see_event, see_notifications,my_profile]
    random.choice(actions)(driver)
    # Once done, close the new tab
    driver.close()

    # Switch back to the main tab
    driver.switch_to.window(main_window)
    # time.sleep(30)  # Wait for 30 seconds before running again

def scroll(driver):
    # Scroll Downward (Max 5 times)
    down_scrolls = 0
    while down_scrolls < 3:
        driver.execute_script("window.scrollBy(0, 500);")  # Scroll down by 500 pixels
        time.sleep(random.uniform(2, 4))  # Random delay
        down_scrolls += 1

    print(f"Scrolled down {down_scrolls} times.")

    print("Reached the bottom of the page.")

    # Scroll back to the top
    while True:
        driver.execute_script("window.scrollBy(0, -500);")  # Scroll up by 500 pixels
        time.sleep(random.uniform(1, 3))  # Random delay
        
        scroll_position = driver.execute_script("return window.pageYOffset;")
        if scroll_position == 0:  # If we are at the top
            break

    print("Scrolled back to the top.")

def check_photos(driver):
    print("I am checkking photos")
    """Clicks on the photos section."""
    try:
        
        # driver.find_element(By.LINK_TEXT, "Photos").click()
        photos_link = WebDriverWait(driver, 10).until(
                    EC.element_to_be_clickable((By.LINK_TEXT, "Photos"))
                )
        move_cursor_to_element(photos_link)
        photos_link.click()
        scroll(driver)
        time.sleep(random.randint(3, 7))
    except:
        pass
def check_friends(driver):
    print("I am checkigf friends")
    """Clicks on the friends section."""
    try:

        # driver.find_element(By.LINK_TEXT, "Friends").click()
        friends_link = WebDriverWait(driver, 10).until(
                    EC.element_to_be_clickable((By.LINK_TEXT, "Friends"))
                )
        move_cursor_to_element(friends_link)
        friends_link.click()
        scroll(driver)
        time.sleep(random.randint(3, 7))
    except:
        pass
def check_videos(driver):
    print("I am checking videos")
    """Clicks on the videos section."""
    try:
        # driver.find_element(By.LINK_TEXT, "Videos").click()
        Videos_link = WebDriverWait(driver, 10).until(
                    EC.element_to_be_clickable((By.LINK_TEXT, "Videos"))
                )
        move_cursor_to_element(Videos_link)
        Videos_link.click()
        scroll(driver)
        time.sleep(random.randint(3, 7))
    except:
        pass
def check_checkins(driver):
    print("I am checking checkns")
    """Clicks on the check-ins section."""
    try:
        check_in_link = WebDriverWait(driver, 10).until(EC.element_to_be_clickable(By.LINK_TEXT,"Check-ins"))
        # driver.find_element(By.LINK_TEXT, "Check-ins").click()
        move_cursor_to_element(check_in_link)
        check_in_link.click()
        scroll(driver)
        time.sleep(random.randint(3, 7))
    except:
        pass


def send_request(driver):
    """
    Clicks the 'Message' button and sends a message via a chat input box.
    
    :param driver: Selenium WebDriver instance
    :param message: Message to send
    """
    try:
        print("I am in the try block of the request button")
        request_button = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, "//div[@aria-label='Add friend']"))
        )
        move_cursor_to_element(request_button)

        print("I hav ound the request button now i am going to scroll to it")
        # driver.execute_script("arguments[0].scrollIntoView(true);", request_button)
        print("request button found")
        variations.random_cursor_movement()
        time.sleep(3)
        request_button.click()
        time.sleep(5)
        try:
            print("I am entering the etry block of the popup window")
            # Wait for the "OK" button to appear (max wait: 5 seconds)
            ok_button = WebDriverWait(driver, 5).until(
                EC.element_to_be_clickable((By.XPATH, "//div[@aria-label='OK' and @role='button']"))
            )
            move_cursor_to_element(ok_button)

            print("I have found ok button")
            # Click the button
            ok_button.click()
            print("âœ… 'OK' button clicked successfully!")

            # Optional: Wait a moment to let the action complete
            time.sleep(2)

        except Exception as e:
            print("âŒ No 'OK' button found or failed to click")
        print("Request button clicked")
        print("Clicked the friend request button.")
    except Exception as e:
        print(f"Error clicking the friend request button: {e}")
        return

def send_message(driver, message):
    """
    Clicks the 'Message' button, checks if the message was already sent, and sends a new one only if necessary.
    
    :param driver: Selenium WebDriver instance
    :param message: Message to send
    """
    try:
        print("Trying to locate the 'Message' button...")
        message_button = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH, "//div[@aria-label='Message']"))
        )
        move_cursor_to_element(message_button)
        print("Cursor moved to the element (pyautogui)")
        
        time.sleep(2)
        print("Message button found, clicking...")
        message_button.click()
    except Exception as e:
        print(f"Error clicking the Message button: {e}")
        return

    # Wait for chat to load
    time.sleep(5)

    try:
        print("Fetching previously sent messages...")
        messages = driver.find_elements(By.XPATH, "//div[contains(@class, 'html-div xdj266r x11i5rnm xat24cr x1mh8g0r xexx8yu x4uap5 x18d9i69 xkhd6sd xeuugli x1vjfegm')]//span")

        # Extract text and clean it up
        sent_messages = [msg.text.strip() for msg in messages if msg.text.strip()]
        print("Retrieved Messages:", sent_messages)  # Debugging

    except Exception as e:
        print(f"Error fetching messages: {e}")
        return

    # Check if the exact message is already sent
    if message.strip() in sent_messages:
        wrote_message=False
        print("Message already sent. Skipping...")
        
        return wrote_message

    try:
        print("Locating the message input box...")
        message_input = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, "//div[@aria-label='Message' and @role='textbox']"))
        )
        move_cursor_to_element(message_input)
        print("Cursor moved to the element (pyautogui)")
       
        print("Found message input box, typing message...")
        human_like_typing(message_input, message)
        time.sleep(random.uniform(0.5, 1.5))  # Small delay before hitting Enter
        message_input.send_keys(Keys.RETURN)
        time.sleep(random.uniform(0.9, 1.5))  # Small delay before hitting Enter
        # actions = ActionChains(driver)
        # actions.move_to_element(message_input).click().send_keys(message.strip() + Keys.RETURN).perform()
        print("Message sent successfully!")
        wrote_message = True
    except Exception as e:
        print(f"Error typing message: {e}")
        wrote_message = False
    return wrote_message

def close_liker_dialog(driver):
    try:
        # Attempt to find and click the close button of the dialog.
        close_button = WebDriverWait(driver, 5).until(
            EC.element_to_be_clickable((By.XPATH, "//div[@role='dialog']//div[@aria-label='Close']"))
        )
        move_cursor_to_element(close_button)
        print("Cursor moved to the element (pyautogui)")
        
        close_button.click()
        time.sleep(2)
        print("Dialog closed.")
    except Exception as e:
        # Fallback: Press Escape key to close the dialog.
        driver.find_element(By.TAG_NAME, "body").send_keys("\u001b")
        time.sleep(2)
        print("Dialog closed using Escape key.")


EXCEL_FILE = "visited_profiles.xlsx"

def extract_base_url(link):
    """Extracts the main profile link, removing query parameters."""
    parsed_url = urlparse(link)
    return f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"

def load_visited_profiles():
    """Loads visited profiles from the Excel file, ensuring column existence."""
    if os.path.exists(EXCEL_FILE):
        try:
            df = pd.read_excel(EXCEL_FILE)
            if "Links" in df.columns:
                return set(df["Links"].dropna())  # Convert to set for fast lookup
            else:
                print("âš  Warning: 'Links' column missing in Excel file. Creating a new one.")
                return set()
        except Exception as e:
            print(f"âŒ Error reading Excel file: {e}")
            return set()
    return set()


def save_visited_profile(profile_url, name, status):
    """Appends a newly visited profile to the Excel file, ensuring 'Links' column exists."""
    if not os.path.exists(EXCEL_FILE):
        df = pd.DataFrame(columns=["Links", "Name", "Status", "Last_Message_Time"])  # Create a new file if it doesn't exist
    else:
        df = pd.read_excel(EXCEL_FILE)
        # Ensure required columns exist
        for col in ["Links", "Name", "Status", "Last_Message_Time"]:
            if col not in df.columns:
                df[col] = []
    # Check if the profile already exists
    # Convert to datetime format
    df["Last_Message_Time"] = pd.to_datetime(df["Last_Message_Time"], errors="coerce")

    # now = datetime.datetime.now()
    # **Only update Last_Message_Time if the message was actually sent**
    last_message_time = datetime.datetime.now()

    if profile_url in df["Links"].values:
        df.loc[df["Links"] == profile_url, ["Name", "Status", "Last_Message_Time"]] = [name, status, last_message_time]
    else:
        new_data = pd.DataFrame({"Links": [profile_url], "Name": [name], "Status": [status], "Last_Message_Time": [last_message_time]})
        df = pd.concat([df, new_data], ignore_index=True)

    df.to_excel(EXCEL_FILE, index=False)

def profiles_reacted(driver, university_name,univer):
    visited_profiles = load_visited_profiles()  # Load existing profiles
    last_height = driver.execute_script("return document.body.scrollHeight")
    scroll_attempts = 0
    max_scroll_attempts = 2  # Adjust as needed
    while True:
        try:

            # Flag to indicate whether any unique profiles were found during scrolling
            unique_profiles_found = False
            profile_elements = driver.find_elements(By.XPATH, 
                "//span/div/span/a[contains(@href, 'facebook.com/profile.php?id=') or contains(@href, 'facebook.com/')]"
            )
            profile_links = [elem.get_attribute("href") for elem in profile_elements if elem.get_attribute("href")]
            # Convert all links to base URLs for comparison
            profile_base_urls = {extract_base_url(link) for link in profile_links}
            unique_people_links = profile_base_urls - visited_profiles  # Compare only base URLs
            if not unique_people_links:
                print("âš  No new unique profiles found. Scrolling down...")
                scroll_attempts += 1
                scrollable_div = driver.find_element(By.CLASS_NAME, 'xb57i2i')
                for _ in range(3):  # Scroll multiple times
                    driver.execute_script("arguments[0].scrollTop += 500;", scrollable_div)
                    time.sleep(1)
                if scroll_attempts >= max_scroll_attempts:
                    print("Reached maximum scroll attempts with no new profiles on this page.")
                    break
                
                time.sleep(random.randint(1,3))
                continue
            else:
                unique_profiles_found = True
                scroll_attempts = 0  
                for profile_base_url in unique_people_links:
                    visited_profiles.add(profile_base_url)  # Store only base URLs
                    
                    # save_visited_profile(profile_base_url, name, status)  # Save to Excel
                    print(f"âœ… Visiting profile: {visited_profiles}")

                    main_window = driver.current_window_handle
                    # Open a new tab
                    driver.execute_script("window.open(arguments[0], '_blank');", profile_base_url)
                    time.sleep(2)  # Wait for the new tab to load
                    all_windows = driver.window_handles

                    # The new tab should be the last handle in the list (if you haven't opened multiple)
                    new_tab = [handle for handle in all_windows if handle != main_window][0]
                    driver.switch_to.window(new_tab)
                    try:
                        profile_name_element = driver.find_element(By.XPATH, "//h1[contains(@class, 'html-h1 xdj266r x11i5rnm xat24cr x1mh8g0r xexx8yu x4uap5 x18d9i69 xkhd6sd x1vvkbs x1heor9g x1qlqyl8 x1pd3egz x1a2a7pz')]")
                        name = profile_name_element.text
                    except:
                        print("Couldnt find the element")
                    # variations.random_cursor_movement()
                    actions = [check_photos, check_friends, check_videos, check_checkins]
                    random.choice(actions)(driver)
                    driver.execute_script("window.scrollBy(0, 200);")
                    about_section = WebDriverWait(driver, 10).until(
                    EC.element_to_be_clickable((By.XPATH, "//a[contains(@href, 'about')]"))
                    )
                    pyautogui.moveTo(400, 50, duration=0.5)
                    move_cursor_to_element(about_section)
                    print("Cursor moved to the element (pyautogui)")
                    
                    actions= ActionChains(driver)
                    actions.move_to_element(about_section).click().perform()
                    target_university = university_name.lower()  # We will match anything containing "Abertay"
                    print(f"The target university is : {target_university}")

                    time.sleep(random.randint(2,5))

                    try:
                        wait = WebDriverWait(driver, 10)

                        text_ = wait.until(EC.presence_of_element_located(
                            (By.XPATH, "//div[contains(@class, 'x13faqbe')]//span[contains(text(), 'Studies')]")
                        ))#or contains(text(), 'Studied')
                        move_cursor_to_element(text_)
                        print("Cursor moved to the element (pyautogui)")
                       
                        print("âœ… Got the text, now comparing with target universities")

                        plain_text = text_.text.lower()
                        print(f"ðŸ“Œ Extracted text: {plain_text}")

                        ignore_words = {"university", "college", "at", "in", "of", "the", "studied", "studies", "study", "technology"}
                        words_in_text = set(plain_text.split()) - ignore_words
                        print(f"ðŸ” Filtered words from extracted text: {words_in_text}")

                        found_match = False
                        for university_name in univer["university"]:
                            words_in_university = set(university_name.lower().split()) - ignore_words
                            matching_words = words_in_text.intersection(words_in_university)

                            if matching_words:
                                print(f"âœ… Match found: {university_name} ðŸŽ¯")

                                # **Check rate limit before sending a message**
                                print("I am before can send message function ")
                                if can_send_message():
                                    
                                    save_visited_profile(profile_base_url, name, status)  # Save to Excel
                                    print("Yes we can send messages and sent mesages variabkle has been initialized")
                                    driver.execute_script("window.scrollTo(0, 0);")
                                    time.sleep(random.randint(2, 5))
                                    send_request(driver)
                                    wrote_message = send_message(driver, "Hello! How are you?")
                                    print("The message was already sent ", wrote_message)
                                    if wrote_message==True:
                                        status = "sent"
                                    elif wrote_message==False:
                                        status = "already send"
                                    # sent_messages.append(datetime.datetime.now())  # Track message timestamp
                                else:
                                    status = "pending"
                                    save_visited_profile(profile_base_url, name, status)  # Save to Excel
                                    
                                found_match = True
                                break  # Stop checking further universities
                                
                        if not found_match:
                            status="not sent"
                            save_visited_profile(profile_base_url, name, status)  # Save to Excel
                            print(f"âš  The overview does not show the person is from a target university.")

                    except TimeoutException:
                        status="not sent"
                        save_visited_profile(profile_base_url, name, status)  # Save to Excel
                        print("âš  No university info found in profile. Skipping this person.")

                    # except Exception as e:
                    #     print(f"âŒ Error during university verification: {str(e)}")




                    time.sleep(3)  # Allow about page to load
                    # Once done, close the new tab
                    driver.close()

                    # Switch back to the main tab
                    driver.switch_to.window(main_window)
                    time.sleep(6)  # Allow profile to load
                
                    
        except Exception as e:
            print(f"âŒ Error extracting or visiting profiles: {e}")
            break
    # Save unmatched profiles to Excel after processing
        # save_profiles_to_excel()
    close_liker_dialog(driver)

def click_all_like_buttons(driver, university_name,visited_profiles,univer):
    time.sleep(5)
    scroll_pause_time = 2  # Adjust for slower or faster scrolling

    last_height = driver.execute_script("return document.body.scrollHeight")
    
    while True:
        driver.execute_script("window.scrollBy(0, 500);")  # Scroll down by 300 pixels
        time.sleep(scroll_pause_time)
        
        new_height = driver.execute_script("return window.scrollY + window.innerHeight")
        if new_height >= last_height:
            break  # Stop when the bottom is reached
    print("I have scrolled to the end")
    like_buttons = driver.find_elements(
    By.XPATH,
    "//div[@role='button' and .//div[@class='x9f619 x1ja2u2z xzpqnlu x1hyvwdk x14bfe9o xjm9jq1 x6ikm8r x10wlt62 x10l6tqk x1i1rx1s' and normalize-space(text())='All reactions:']]"  # add additional conditions as needed
)
    
    print(f"Found {len(like_buttons)} like button(s).")
    for index, btn in enumerate(like_buttons):
        try:
            # Scroll into view if necessary
            driver.execute_script("arguments[0].scrollIntoView(true);", btn)
            time.sleep(1)
            if btn.is_displayed():
                print("The button is displayed")
                move_cursor_to_element(btn)
                print("Cursor moved to the element (pyautogui)")
                time.sleep(1)
                driver.execute_script("arguments[0].click();", btn)
                
                time.sleep(3)
                print(f"The visited profiles are \n {visited_profiles}")
                profiles_reacted(driver, university_name,univer)

            else:
                print("Button is not displayed")

            print(f"Clicked like button {index+1}")
            time.sleep(2)  # Adjust delay as needed for actions to take effect
        except Exception as e:
            print(f"Error clicking like button {index+1}: {e}")
        
# Function to initialize the Selenium WebDriver
def init_driver():
    options = uc.ChromeOptions()
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-dev-shm-usage")
    
    # Set the user data directory to store the session
    options.add_argument(r'--user-data-dir=C:\\Users\\Mahnoor-Zubair\\Desktop\\sessions')

    driver = uc.Chrome(version_main=133, options=options)
    return driver

# Function to handle the login process
def main_handler(username, password, univer, index, requester):
    driver = init_driver()
    # Log session start time
    start_time = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    # session("started",start_time)
    driver.get("https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fspeaking.email   ")
    time.sleep(2)  # Allow page to load
    
    try:
        # Locate and enter username
        email_input = driver.find_element(By.ID, "email")
        email_input.send_keys(username)

        # Locate and enter password
        password_input = driver.find_element(By.ID, "pass")
        password_input.send_keys(password)
        password_input.send_keys(Keys.RETURN)
        time.sleep(5)  # Wait for login to complete
        
    except:
        pass

    # Check login success
    if "login_attempt" in driver.current_url:
        print(f"Login failed for {username}")
    else:
        print(f"Login successful for {username}")
        time.sleep(5)
        
        try:
            # Wait for the close button to be visible and get its location
            close_button = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, "//div[@aria-label='Close']"))
            )

            move_cursor_to_element(close_button)
            print("Cursor moved to the close button")

            close_button.click()
            print("Close button clicked successfully!")

        except Exception as e:
            print(f"An error occurred: {e}")
            # variations.random_cursor_movement()
            time.sleep(2)
            print("Close button has been clicked")
            print("Post window closed successfully.")

        except Exception as e:
            print(f"Error closing post window: {e}")

        if not univer.empty:
            try:
                for _, uni_row in univer.iterrows():  # âœ… Corrected Loop
                    driver.get("https://www.facebook.com/")
                    university_name = uni_row['university']  # âœ… Now updates correctly for each row
                    print(f"Processing university: {university_name} for {username}")
                    ############################################# THIS IS WHAT I HAVE ADDED ##############################################
                    # time.sleep(555)
                    my_variations(driver)
                    
                    # Search for the university
                    try:
                        search_box = WebDriverWait(driver, 10).until(
                            EC.presence_of_element_located((By.XPATH, "//input[@type='search']"))
                        )
                        move_cursor_to_element(search_box)
                        print("Cursor moved to the close button")

                        driver.execute_script("arguments[0].value = '';", search_box)  # âœ… JavaScript clear
                        search_box.send_keys(Keys.CONTROL + "a")  # âœ… Select all text
                        search_box.send_keys(Keys.BACKSPACE)  # âœ… Delete existing text
                        
                        time.sleep(1)  # Small delay to ensure clearing
                        # university_name = univer.iloc[index]['university']
                        human_like_typing(search_box, university_name)
                        time.sleep(random.uniform(0.5, 1.5))
                        # search_box.send_keys(university_name)
                        search_box.send_keys(Keys.RETURN)
                        time.sleep(random.randint(3, 6))  # Wait for search results
                        print(f"Searching for university: {university_name}")

                    except Exception as e:
                        print(f"Error searching university: {e}")

                    try:
                        pages_filter  = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, "//span[text()='Pages']")))
                        print("Page filter was found")
                        move_cursor_to_element(pages_filter)
                        print("Cursor moved to the element (pyautogui)")
                        pages_filter.click()
                        print("Clicked on the pages filter")
                        time.sleep(random.randint(3, 6))
                    except Exception as e:
                        print(f"error clicking on the 'pages' filter : {e}")
                        time.sleep(random.randint(1, 5))

                    try:
                        variations.random_cursor_movement()
                        # Get all page links
                        page_elements = WebDriverWait(driver, 10).until(
                            EC.presence_of_all_elements_located((By.XPATH, "//a[contains(@href, 'facebook.com')]"))
                        )
                        
                        visited_links = set()
                        matching_links = []
                        for page in page_elements:
                            page_name = page.text.strip().lower()
                            page_link = page.get_attribute('href')
                            # Check if "society" is in the name
                            if ("society" in page_name or 
                                "club" in page_name or 
                                "community" in page_name or 
                                "communities" in page_name):
                                
                                if page_link not in visited_links:
                                    visited_links.add(page_link)
                                    matching_links.append(page_link)
                                    print(f"Society Page Found: {page_name} -> {page_link}")

                                    # driver.get(page_link)
                                    # time.sleep(5)
                        
                        visited_profiles = set()
                        for link in matching_links:
                            try:
                                print(f"\nVisiting page: {link}")
                                driver.get(link)
                                time.sleep(random.randint(2,5))  # Allow time for the page to load

                            
                                # Load the Excel file
                                df = pd.read_excel(r"C:\Users\Mahnoor-Zubair\Desktop\main - Copy\main - Copy\visited_profiles.xlsx")

                                # Filter profiles with "pending" status
                                filtered_df = df[df["Status"] == "pending"][["Links"]]
                                print("I am filtering only the prending profiles")
                                # Store the main window handle
                                main_window = driver.current_window_handle  

                                # Iterate through pending profiles
                                for link in filtered_df["Links"]:
                                    print("i am in the for loop of the profiles that have been got")
                                    if can_send_message():
                                        driver.execute_script("window.open(arguments[0], '_blank');", link)
                                        time.sleep(2)  # Allow new tab to load

                                        # Switch to the new tab
                                        new_tab = [handle for handle in driver.window_handles if handle != main_window][-1]
                                        driver.switch_to.window(new_tab)

                                        # Send the message
                                        wrote_message = send_message(driver, "Hello! How are you?")
                                        print("The message was already sent ", wrote_message)  
                                        time.sleep(3)  # Wait for message to send
                                        if wrote_message==True:
                                            status = "sent"
                                        elif wrote_message==False:
                                            status = "already send"
                                        # Update the status and last message time in the DataFrame
                                        
                                        df.loc[df["Links"] == link, ["Status", "Last_Message_Time"]] = [status, datetime.datetime.now()]
                                        

                                        # Close the new tab and switch back
                                        driver.close()
                                        driver.switch_to.window(main_window)

                                # Save the updated DataFrame back to the Excel file
                                df.to_excel(r"C:\Users\Mahnoor-Zubair\Desktop\main - Copy\main - Copy\visited_profiles.xlsx", index=False)
                                print("âœ… Updated Excel file: Status changed to 'sent' for messaged profiles.")

                                try:
                                        click_all_like_buttons(driver, university_name,visited_profiles,univer)
                                        
                                        # close_liker_dialog(driver)
                                except Exception as e:
                                    print(f"Error finding the post and clicking on the like button {e}")
                                    # Navigate back to the previous page
                                    driver.back()
                                    print("Went back to the previous page")

                                    # Wait for a short period to ensure page is reloaded
                                    time.sleep(2)


                            except Exception as e:
                                print(f"Error visiting {link}: {e}")
                                    
                    except Exception as e:
                        print(f"Error extracting page links: {e}")
                
                
            except Exception as e:
                print(f"Error fetching university data: {e}")
    
    driver.quit()
    # Log session end time
    end_time = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    # session("ended",end_time)
    print("th estart time is ", start_time, "and the end time is ", end_time)
    # Log both times in the same row
    log_to_csv(csv_filename, start_time, end_time)

if __name__ == "__main__":
    # Load account credentials
    accounts = pd.read_csv("account.csv")
    univer = pd.read_csv("uni.csv")
    
    for i, row in accounts.iterrows():
        
        uname = row['username']
        pas = row['password']
        main_handler(uname, pas, univer, i, "requester")